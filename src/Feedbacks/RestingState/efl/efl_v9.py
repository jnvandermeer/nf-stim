#!/usr/bin/env python2 (obviously)
# -*- coding: utf-8 -*-
"""
Created on Tue Aug 21 15:25:56 2018

Version 5 Ready: 1st of September -- 12 days.

@author: johan
"""

#%% COMMENTS
''' So the thing is to deconstruct the bigger problem into a lot of solutions 
for much smaller problems. This is especially true, for the EFL with
visual, auditory and stop-inhibition (staircased) components that operate
interleaved

There's no way one could do this with builder, but (hopefully) with coder
and some help from asyncio, things could work.


This massive beast actually uses Trollius, the asyncio-equivalent of async in python2
The time-inaccuracy per ~2.5 seconds is about 0.06-8 ish seconds. Which is ~ 3-5 frame
flips. So the async really works!

To make the visual markers behave -- I use the win.callOnFlip() to sync markers to the
windows refresh. Timing inaccuracy is tied very closely to the screen flip rate.
A typical flip rate is 1/60, so timing inaccuracy is by DEFINITION then automatically
already 0.016666 seconds. So much for msec-time-accuracy. But at least, the marker
will be accurate to the frame flip, which should improve to msec-precision, where
the inaccuracy is generated by how fast the EEG system can detect/process the markers.
'''



#%% Importing Statements
# importing statements:


import re
import random
import os
import pickle
import sys
import traceback
import time
import glob
import eventhandler
import visualHelper

# import pyglet
from psychopy import visual, clock, data, event, logging, sound, parallel, monitors
import numpy as np

# the assync stuff:
import trollius as asyncio
from trollius import From


if __name__ == "__main__":
    eh=eventhandler.eventHandler(clock.Clock(),{'a':1,'b':2})
    eh.start()
    for x in range(5):
        time.sleep(2)
        eh.send_message('a')
        time.sleep(2)
        eh.send_message('b')


    eh.shutdown()
    eh.join()
# if __name__ != "__main__":
    # run in 'called' fashion using from efl.efl_v6 import *
    # om . import eventhandler
    # from . import visualHelper
# else:
    # run as script with green 'Play' button in Spyder:
    # import visualHelper
    # import eventhandler


# my helper, using RELATIVE import -- since it's a file next to this one, and
# this file should remain there.
# playing with the python Main module. So whenever you do stuff from somewhere else --
# either work in the MAIN module, blabla, or handle things like this:
print('----------')
print('----------')
print (__name__)






