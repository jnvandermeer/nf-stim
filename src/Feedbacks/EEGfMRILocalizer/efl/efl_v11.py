#!/usr/bin/env python2 (obviously)
# -*- coding: utf-8 -*-
"""
Created on Tue Aug 21 15:25:56 2018

Version 5 Ready: 1st of September -- 12 days.

@author: johan
"""

#%% COMMENTS
''' So the thing is to deconstruct the bigger problem into a lot of solutions 
for much smaller problems. This is especially true, for the EFL with
visual, auditory and stop-inhibition (staircased) components that operate
interleaved

There's no way one could do this with builder, but (hopefully) with coder
and some help from asyncio, things could work.


This massive beast actually uses Trollius, the asyncio-equivalent of async in python2
The time-inaccuracy per ~2.5 seconds is about 0.06-8 ish seconds. Which is ~ 3-5 frame
flips. So the async really works!

To make the visual markers behave -- I use the win.callOnFlip() to sync markers to the
windows refresh. Timing inaccuracy is tied very closely to the screen flip rate.
A typical flip rate is 1/60, so timing inaccuracy is by DEFINITION then automatically
already 0.016666 seconds. So much for msec-time-accuracy. But at least, the marker
will be accurate to the frame flip, which should improve to msec-precision, where
the inaccuracy is generated by how fast the EEG system can detect/process the markers.
'''



#%% Importing Statements
# importing statements:


import re
import random
import os
import pickle
import sys
import traceback
import time
import glob
import random




# import pyglet
from psychopy import visual, clock, data, event, logging, sound, monitors
import numpy as np

# the assync stuff:
import trollius as asyncio
from trollius import From



# I guess...
#if __name__ == "__main__":
import eventhandler
import visualHelper
#else:
#    from . import visualHelper
#    from . import eventhandler



#%% Some REALLY global variables

# this is a trick to allow another script, that imports THIS script, to set all of the local variables
# BEFORE the following stimulus declarations are going to run.

def init_G():  # so we do this ourselves in the pyff framework:
    if __name__== "__main__":
        
        
        v=dict()
        
        
        v['STARTKEYS'] = ['return','t']
        v['MONITOR_PIXWIDTH']=1280
        v['MONITOR_PIXHEIGHT']=1024
        v['MONITOR_WIDTH']=40.  # width of screen
        v['MONITOR_HEIGHT']=30.  # height of screen
        v['MONITOR_DISTANCE']=70.  # distance to screen
        v['MONITOR_GAMMA']=1.
        v['MONITOR_FPS']=60.
        v['MONITOR_USEDEGS']=True
        v['MONITOR_DEGS_WIDTHBASE']=25
        v['MONITOR_DEGS_HEIGHTBASE']=20
        v['MONITOR_FLIPHORIZONTAL'] = False
        v['MONITOR_FLIPVERTICAL'] = False
        
        v['MONITOR_NSCREENS']=2
        v['MONITOR_DISPLAYONSCREEN']=1
        v['MONITOR_FULLSCR'] = False
        v['MONITOR_ALLOWGUI'] = False
        
        v['LOGDIR']='log'  # for if you want to change this...
        v['LOGFILEBASE']='efl'  # how to call our logfile --> it adds a number each time
        v['IPADDRESS']='localhost'  # port and ip to send codes towards to
        v['PORT']=6050  # which port is nice?  
        v['BUTTONS'] = ['lctrl', 'rctrl']  # the button codes coming out of event.getStim()
        v['tooSoonTime']=0.0  # if it's pressed before this time --> discard + error
        v['LPT_TRIGGER_WAIT']=0.005  # how long are the LPT port pulses?
        v['RECORDFRAMEINTERVALS'] = True  # for debugging..
        v['DO_VISUAL'] = True
        v['DO_AUDIO'] = True
        v['DO_GNG'] = True
        v['GNGSPEED'] = 1.0
        v['GNG_ARROWGOESRED'] = False
        v['GNG_ARROWGOESRED_DELAY'] = 0.25
        v['AUDIOTONE_ERROR_COMMISSION'] = False
        v['AUDIOTONE_STOP'] = True
        v['VIS_SHOWOPPOSITE'] = False
        v['VIS_radialFreq']=6
        v['VIS_angleFreq']=6
        v['VIS_checkerSize']=1.5
        v['VIS_checkerSpeedMultiplier']=1.0
        v['EYESCLOSED_TIME']=25.
        
        v['EVENT_destip']='127.0.0.1'
        v['EVENT_destport']=6050
        v['EVENT_LPTAddress']=0x0378
        v['EVENT_LPTTrigWaitTime']=0.005
        v['EVENT_TRIGLOG']='log/triggerlog.log'
        v['EVENT_sendParallel']=True
        v['EVENT_sendTcpIp']=True
        v['EVENT_sendLogFile']=True
        v['EVENT_printToTerminal']=True
        v['EVENT_printToTerminalAllowed']=[0, 40]  # only allow the stops, which are < 40.
        
        v['INSTR']='GO - NOGO Task\nRemember, respond as FAST as you can once you see the arrow.\n\n'+'However, if you see it becomes RED, your task is to STOP yourself '+'from pressing.\n\n'+'Stopping and Going are equally important.'
        # INSTR='Remember, respond as FAST as you can once you see the arrow.\n'+'However, if you hear a beep, your task is to STOP yourself \n'+'from pressing. Stopping and Going are equally important.'
    
        # because I put the settings file into one directory lower than this one, if it's called from another script.
        # so tasks should always be contained within their own directory (name doesn't matter)
        # settingsfile=os.path.join(os.path.dirname(os.path.realpath(__file__)),'..', 'settings.pkl')
        # with open(settingsfile,'rb') as f:
        #     v=pickle.load(f)
        # G['v']=v
        G=dict()
        G['v']=v
        #
        # global variable with references to desired memory locations is easier to pass around.
        mainClock=clock.Clock()
        G['mainClock']=mainClock
    return(G)

    # DO_AUDIO=True

    # G['win']=win    
    # only use the G if it's going to be used later on in the gonogo, in the stop or in the visual



#for key in v.keys():
#    locals()[key] = v[key]
    
    
# some time to wait for loading to complete?
# save to picke:


# and here we set the locals, so that the following (Commented) section is true.
# this is the stackexchange neat trick to set local variables.




    # variables are fine...
    #
    ##%% some kind of function that will set the values within this namespace. This function will be automatically called.
    #
    #MONITOR_PIXWIDTH=1440
    #MONITOR_PIXHEIGHT=900
    #MONITOR_WIDTH=40.  # width of screen
    #MONITOR_HEIGHT=30.  # height of screen
    #MONITOR_DISTANCE=70.  # distance to screen
    #MONITOR_GAMMA=1.
    #MONITOR_FPS=60.
    #MONITOR_USEDEGS=True
    #MONITOR_DEGS_WIDTHBASE=25
    #MONITOR_DEGS_HEIGHTBASE=20
    #MONITOR_FLIPHORIZONTAL = False
    #MONITOR_FLIPVERTICAL = False
    #
    #MONITOR_NSCREENS=1
    #MONITOR_DISPLAYONSCREEN=1
    #MONITOR_FULLSCR = False
    #MONITOR_ALLOWGUI = True
    #
    #LOGDIR='log'  # for if you want to change this...
    #LOGFILEBASE='efl'  # how to call our logfile --> it adds a number each time
    #IPADDRESS='localhost'  # port and ip to send codes towards to
    #PORT=6050  # which port is nice?  
    #BUTTONS = ['lctrl', 'rctrl']  # the button codes coming out of event.getStim()
    #tooSoonTime=0.0  # if it's pressed before this time --> discard + error
    #LPT_TRIGGER_WAIT=0.005  # how long are the LPT port pulses?
    #RECORDFRAMEINTERVALS = True  # for debugging..
    #DO_VISUAL = True
    #DO_AUDIO = True
    #DO_GNG = True
    #GNGSPEED = 1.0
    #GNG_ARROWGOESRED = False
    #AUDIOTONE_ERROR_COMMISSION = False
    #AUDIOTONE_STOP = True
    #VIS_SHOWOPPOSITE = False
    #VIS_radialFreq=6
    #VIS_angleFreq=6
    #VIS_checkerSize=1.5
    #EYESCLOSED_TIME=25.
    #
    #EVENT_destip='127.0.0.1'
    #EVENT_destport=6050
    #EVENT_LPTAddress=0x0378
    #EVENT_LPTTrigWaitTime=0.005
    #EVENT_TRIGLOG='log/triggerlog.log'
    #EVENT_sendParallel=True
    #EVENT_sendTcpIp=True
    #EVENT_sendLogFile=True
    #EVENT_printToTerminal=True
    #EVENT_printToTerminalAllowed=range(256)  # only allow the stops, which are < 40.



#%% Initialize the Window

def init_screen(G):
    MONITOR_WIDTH=G['v']['MONITOR_WIDTH']
    MONITOR_DISTANCE=G['v']['MONITOR_DISTANCE']
    MONITOR_PIXWIDTH=G['v']['MONITOR_PIXWIDTH']
    MONITOR_PIXHEIGHT=G['v']['MONITOR_PIXHEIGHT']
    MONITOR_NSCREENS=G['v']['MONITOR_NSCREENS']
    MONITOR_USEDEGS=G['v']['MONITOR_USEDEGS']
    MONITOR_DISPLAYONSCREEN=G['v']['MONITOR_DISPLAYONSCREEN']
    MONITOR_FLIPHORIZONTAL=G['v']['MONITOR_FLIPHORIZONTAL']
    MONITOR_FLIPHORIZONTAL=G['v']['MONITOR_FLIPHORIZONTAL']
    RECORDFRAMEINTERVALS=G['v']['RECORDFRAMEINTERVALS']
    MONITOR_FULLSCR=G['v']['MONITOR_FULLSCR']
    MONITOR_ALLOWGUI=G['v']['MONITOR_ALLOWGUI']
    MONITOR_FPS=G['v']['MONITOR_FPS']
    
    mon = monitors.Monitor('current', width=MONITOR_WIDTH, distance=MONITOR_DISTANCE, gamma=None)
    # mon.setDistance(MONITOR_DISTANCE)  # in CM
    # mon.setWidth(MONITOR_WIDTH)  # in cm?
    mon.setSizePix((MONITOR_PIXWIDTH,MONITOR_PIXHEIGHT))  # an INT?
    
    # in win definition, monitor=mon
    # in shapes definition; setSize((x, y), units='deg')  ## then use that...
    #
    #	SCREEN_SIZE = (1440,900)        
    #	win0 = visual.Window(SCREEN_SIZE, monitor='Monitor_00', screen=0, fullscr=False, allowGUI=True,winType='pyglet')
    #        win1 = visual.Window(SCREEN_SIZE, monitor='Monitor_01', screen=1, fullscr=False, allowGUI=True,winType='pyglet')
    #        win2 = visual.Window(SCREEN_SIZE, monitor='Monitor_02', screen=2, fullscr=False, allowGUI=True,winType='pyglet')
    #
    #        # the TRICK == to then close win1.
    #        # win0 is (always?) the window which is where the main Desktop UI resides
    #        self.win=win0
    #        win1.close()
    #        win2.close()
    #        print('PsychoPy initialized')
    
    
    tmpwin=[]
    for i in range(MONITOR_NSCREENS):
        
        if MONITOR_USEDEGS is True:
            tmpwin.append(visual.Window(size=(MONITOR_PIXWIDTH,MONITOR_PIXHEIGHT), fullscr=MONITOR_FULLSCR, screen=int(i+1), allowGUI=MONITOR_ALLOWGUI, winType='pyglet', waitBlanking=False, monitor=mon, units='deg', autoLog=False))
        else:
            tmpwin.append(visual.Window(size=(MONITOR_PIXWIDTH,MONITOR_PIXHEIGHT), fullscr=MONITOR_FULLSCR, screen=int(i+1), allowGUI=MONITOR_ALLOWGUI, winType='pyglet', waitBlanking=False))
        
    # we pick the screen.    
    win=tmpwin[MONITOR_DISPLAYONSCREEN-1]
    # and close off the other screens.
    for i in range(MONITOR_NSCREENS):
        if i != (MONITOR_DISPLAYONSCREEN-1):
            tmpwin[i].close()
    
    
    if MONITOR_FLIPHORIZONTAL is True and MONITOR_FLIPHORIZONTAL is False:
        win.viewScale = (-1, +1)
    if MONITOR_FLIPHORIZONTAL is False and MONITOR_FLIPHORIZONTAL is True:
        win.viewScale = (+1, -1)
    if MONITOR_FLIPHORIZONTAL is True and MONITOR_FLIPHORIZONTAL is True:
        win.viewScale = (-1, -1)
    # don't touch the False and False, since that's the default setting..
    
    
    win.recordFrameIntervals = RECORDFRAMEINTERVALS  # record frame intervals...
    FPS=MONITOR_FPS  # frames per second of your screen
    # access with: win.frameIntervals
    G['win']=win
    return(G)
    # since we're dealing with a couple of loops that are intermixed, and global variables are evil, at least
    # do this -- make a dict that contains all variables that are needed so that the intermixed loops all
    # require only ONE input argument, which helps me with the async stuff later on.
    
    
    
    



    #%% LOGGING I - The psychopy Logfile
def init_logfile(G):
    LOGFILEBASE=G['v']['LOGFILEBASE']
    LOGDIR=G['v']['LOGDIR']
    # figure out if there's a log directory, if not --> make it:
    # another trick for path compliance, when called with an import:
    if __name__ != "__main__":
        LOGDIR = os.path.join(os.path.dirname(os.path.realpath(__file__)),LOGDIR)
    
    if not os.path.exists(LOGDIR):
        os.makedirs(LOGDIR)
    
    # figure out which files reside within this logfile directory:
    if len(glob.glob(LOGDIR+os.sep+LOGFILEBASE+'*.log')) == 0:
        logcounter=0
    else:
        # figure out biggest number:
        #logcounter = max([int(match.group(1)) 
        #for match in [re.match(LOGFILEBASE+'([0-9]*)'+'.log',item) 
        #for item in os.listdir(LOGDIR)]])
    
        # figure out biggest number:
        matches=[match for match in [re.match(LOGFILEBASE+'([0-9]*)'+'.log',item) for item in os.listdir(LOGDIR)]]
        newlist=[]
        for match in matches:
            if match is not None:
                newlist.append(match.group(1))
        logcounter = max([int(n) for n in newlist])
    
    
    # so make just another logfile on top of this one -- it'll be timestamped    
    logcounter += 1
    
    # this is the new logfile:
    newLogFile=os.path.join(LOGDIR, LOGFILEBASE+'%d.log' % logcounter)
    print('Logfile for off-line analysis: %s\n' % newLogFile)
    
    
    # open up a log:
    logging.setDefaultClock(G['mainClock'])
    expLogger = logging.LogFile(newLogFile, logging.EXP) # the correct loglevel should be EXP!
    
    
    # write out the settings into logfile:
    logging.data("---------------------------")
    logging.data("---------------------------")
    logging.data("Settings of the experiment:")
    for key in G['v'].keys():
        logging.data("{key}: {value}".format(key=key, value=G['v'][key]))
    logging.data("---------------------------")
    logging.data("---------------------------")
    # this ensures that all kinds of Exp thingies are written. DATA, WARNING and ERROR are higher
    # but INFO and DEBUG won't be used.
    # this is actually useful.
    
    
    # so -- write stuff away with logging.data('blabla'); logging;flush()
    # then -- logging.data('message') --> will give timestamped stuff
    # logging.flush() --> to ACTUALLY WRITE it to the file!
    
    # many (!!) of the stimuli also create a logging trigger, but you'd need to flush it
    # in order to write it as-you-go
    # otherwise it'll only happen at the end of the experiment
    # and if there is an error of some sort --> bad luck, if you relied on loggin
    # for your experimental logfile data crawlers, you just lost EVERYTHING.
    G['expLogger']=expLogger
    return(G)


    #%% Define Visual and GoNogo Stimuli
    # make the dicts of visual and stop-inhibition stimuli:
    # build a dict of visuals:
def init_stimuli(G):

    
    VIS_radialFreq=G['v']['VIS_radialFreq']
    VIS_angleFreq=G['v']['VIS_angleFreq']
    VIS_checkerSize=G['v']['VIS_checkerSize']
    MONITOR_USEDEGS=G['v']['MONITOR_USEDEGS']
    MONITOR_DEGS_WIDTHBASE=G['v']['MONITOR_DEGS_WIDTHBASE']
    MONITOR_DEGS_HEIGHTBASE=G['v']['MONITOR_DEGS_HEIGHTBASE']
    
    
    
    win=G['win']
    vstims=dict()
    sstims=dict()
    radialFreq=VIS_radialFreq
    angleFreq=VIS_angleFreq
    checkerSize=VIS_checkerSize
    cicleSize=checkerSize/12*2
    stimSize=checkerSize/12*1.5
    
    AUTOLOGIT = True
    
    
    checkr=visual.RadialStim(win, tex='sqrXsqr', ori=0, size=checkerSize, 
                         visibleWedge=(0, 181),
                         angularCycles=angleFreq, radialCycles=radialFreq, autoLog=AUTOLOGIT)
    
    checkrf=visual.RadialStim(win, tex='sqrXsqr', ori=0, size=checkerSize, 
                         visibleWedge=(0, 181),
                         angularCycles=angleFreq, radialCycles=radialFreq, autoLog=AUTOLOGIT)
    checkrf.setContrast(-1)
    
    
    #checkrf=visual.RadialStim(win, tex='sqrXsqr', ori=-90, size=checkerSize, 
    #                     visibleWedge=(90, 271),
    #                     angularCycles=angleFreq, radialCycles=radialFreq, autoLog=AUTOLOGIT)
    
    checkl=visual.RadialStim(win, tex='sqrXsqr', ori=0, size=checkerSize, 
                         visibleWedge=(180, 360),
                         angularCycles=angleFreq, radialCycles=radialFreq, autoLog=AUTOLOGIT)
    
    
    checklf=visual.RadialStim(win, tex='sqrXsqr', ori=0, size=checkerSize, 
                         visibleWedge=(180, 360),
                         angularCycles=angleFreq, radialCycles=radialFreq, autoLog=AUTOLOGIT)
    checklf.setContrast(-1)
    
    #checklf=visual.RadialStim(win, tex='sqrXsqr', ori=90, size=checkerSize, 
    #                     visibleWedge=(90, 271),
    #                     angularCycles=angleFreq, radialCycles=radialFreq, autoLog=AUTOLOGIT)
    
    
    
    
    circ=visual.Circle(win, radius=cicleSize, fillColor=[0,0,0], lineColor=[0, 0, 0], autoLog=AUTOLOGIT)
    
    fa=.1;fb=1
    fixationVert = [(fa, fa),(fa, fb),(-fa, fb),(-fa, fa),(-fb, fa),(-fb, -fa),
                    (-fa, -fa),(-fa, -fb),(fa, -fb),(fa, -fa),(fb, -fa), (fb, fa)]
    fixation = visual.ShapeStim(win, vertices=fixationVert, fillColor='red', 
                             size=stimSize/7.5, ori=0, lineColor='red', autoLog=AUTOLOGIT)
    
    
    
    
    vstims['r']=[checkr, circ, fixation]
    vstims['rf']=[checkrf, circ, fixation]
    vstims['l']=[checkl, circ, fixation]
    vstims['lf']=[checklf, circ, fixation]


    
    #if MONITOR_USEDEGS is True:
    #    
    #
    #    f_x = MONITOR_DEGS_WIDTHBASE / checkerSize
    #    f_y = MONITOR_DEGS_HEIGHTBASE / checkerSize
    #   
    #    # newCheckerSize=(MONITOR_DEGS_WIDTHBASE, MONITOR_DEGS_HEIGHTBASE)
    #    
    #    for item in 
    #        
    #        print(item)
    #        oldsize=item.size
    #    
    #        newsize = (oldsize[0]*f_x, oldsize[1]*f_y)
    #        
    #        item.setSize(newsize) # , units='deg')
            
            


    stimcirc1=visual.Circle(win, radius=stimSize, fillColor=[1, 1, 1], lineColor=[1, 1, 1], autoLog=AUTOLOGIT)
    stimcirc2=visual.Circle(win, radius=stimSize/1.5*1.37, fillColor=[0, 0, 0], lineColor=[1, 1, 1], autoLog=AUTOLOGIT)
    
    
    #al=visual.ImageStim(win, image=u'stims/arrow.png')
    
    arrowPinch=1.75;
    arrowVert = [(-0.7071, -0.7071/arrowPinch), (0, -0.7071/arrowPinch),
                  (0, -1), (1, 0),
                  (0, 1),(0, 0.7071/arrowPinch), 
                  (-0.7071, 0.7071/arrowPinch)]
    
    arrowl = visual.ShapeStim(win, vertices=arrowVert, fillColor='white', 
                             size=stimSize/1.973, ori=180, lineColor='white', autoLog=AUTOLOGIT)
    
    arrowr = visual.ShapeStim(win, vertices=arrowVert, fillColor='white', 
                             size=stimSize/1.973, ori=0, lineColor='white', autoLog=AUTOLOGIT)
    
    arrowlr = visual.ShapeStim(win, vertices=arrowVert, fillColor='darkred', 
                             size=stimSize/1.973, ori=180, lineColor='darkred', autoLog=AUTOLOGIT)
    
    arrowrr = visual.ShapeStim(win, vertices=arrowVert, fillColor='darkred', 
                             size=stimSize/1.973, ori=0, lineColor='darkred', autoLog=AUTOLOGIT)
    
    
    sstims['pre']=[stimcirc1, stimcirc2]
    sstims['fix']=[fixation]
    
    sstims['al']=[stimcirc1, stimcirc2, arrowl]
    sstims['ar']=[stimcirc1, stimcirc2, arrowr]
    sstims['alr']=[stimcirc1, stimcirc2, arrowlr]
    sstims['arr']=[stimcirc1, stimcirc2, arrowrr]



    if MONITOR_USEDEGS is True:
        
    
        f_x = MONITOR_DEGS_WIDTHBASE / checkerSize
        f_y = MONITOR_DEGS_HEIGHTBASE / checkerSize
       
        # newCheckerSize=(MONITOR_DEGS_WIDTHBASE, MONITOR_DEGS_HEIGHTBASE)
        
        for item in [
                checkl, 
                checklf, 
                checkr, 
                checkrf, 
                circ, 
                fixation,
                stimcirc1, 
                stimcirc2, 
                arrowl, 
                arrowr, 
                arrowlr, 
                arrowrr 
                ]:
            
            print(item)
            oldsize=item.size
        
            newsize = (oldsize[0]*f_x, oldsize[1]*f_y)
            
            item.setSize(newsize) # , units='deg')
    
    
    
    
    
    G['vstims']=dict()
    G['vstims']['V']=vstims
    G['vstims']['S']=sstims
    
    return(G)
    # G['vstims']['eyesclosed']=eyesclosed
    
    # G['vstims']['eyesclosed']=eyesclosed


    #%% LOGGING II - Spread Markers to All The World
    # these are the visual evt codes that I conceived a while ago:
        
            
    # customized message handler + how-to-send codes that won't break equipment
    # just make sure that the code < 255, always.
def init_eventcodes(G):
    MSGDICT={
            
            # Stop / Inhibit Response Codes
            'BeginGoL':1,
            'BeginGoR':2,
            'BeginStopL':3,
            'BeginStopR':4,
            
            'RespL':5,
            'RespR':6,
    
            # somce some responses are not logged (because of too soon or too late or multiple presses)
            # log the keyboard separately.
            'KeyL': 7,        
            'KeyR': 8,
            'WrongKey': 9,
    
            'CorrectGoL':11,
            'CorrectGoR':12,
            'CorrectStopL':13,
            'CorrectStopR':14,
            'ErrorCommission':15,
            
            # don't expect too many of these:
            'ErrorOmission':21,
            'PressedTooSoon':22,
            'PressedTooLate':23,
            'TooManyResponses':24,
            'WrongSideErrorCommission':25,
            'WrongSideGo':26,
            
            'gonogo_BEGIN': 30,
            'gonogo_END': 31,
    
            
    
            # visual SSVEP checkerboard codes (8 and 13 Hz)
            #
            # when the contrast inverts, for SSVEP deconvolution
            'vis_l8':81,
            'vis_r8':82,
            'vis_l13':131,
            'vis_r13':132,
    
            # begin and end markers (for EEG frequency analysis), 8Hz and 13Hz
            'vis_bl8':83,
            'vis_br8':84,
            'vis_el8':85,
            'vis_er8':86,
     
            'vis_bl13':133,
            'vis_br13':134,
            'vis_el13':135,
            'vis_er13':136,
    
            'vis_BEGIN': 80,
            'vis_END': 140,
    
            # audio SSVEP codes (40 Hz and 55 Hz)
            #
            # when audio sample starts -- one audio sample contains 32 
            'aud_l40':41,
            'aud_r40':42,
            'aud_l55':51,
            'aud_r55':52,
    
            'aud_bl40':43,
            'aud_br40':44,
            'aud_el40':45,
            'aud_er40':46,
     
            'aud_bl55':53,
            'aud_br55':54,
            'aud_el55':55,
            'aud_er55':56,
            
            'aud_BEGIN': 40,
            'aud_END': 60,

            
            'eo_BEGIN': 201,
            'eo_END': 202,
            'ec_BEGIN': 203,
            'ec_END': 204,




            'h4l':221,
            'h4r':222,
            'h8l':223,
            'h8r':224,
            'v4u':225,
            'v4d':226,
            'v8u':227,
            'v8d':228, 
            'c':229, 
            'hvest':231,
            'hvestp':232,
            'vvest':233,
            'vvestp':234,
            'eyeblinks':241,
            'neckl':242,
            'neckr':243,
            'jaw':244,
            'eyebrows':245,
            'swallow':246,

                
            }        
            
    
    
    
    
        
    EVENT_TRIGLOG=G['v']['EVENT_TRIGLOG']
    # another check...
    if __name__ != "__main__":
        EVENT_TRIGLOG = os.path.join(os.path.dirname(os.path.realpath(__file__)),EVENT_TRIGLOG)
    
    
    G['evcodes']=MSGDICT
    
    G['EVENT_TRIGLOG']=EVENT_TRIGLOG
    
    return(G)
    #                     messagedict,
    #                     clock, 
    #                     ip='127.0.0.1', 
    #                     port=6500, 
    #                     LPTAddress=0x0378,
    #                     filename='log/triggerlog.log',
    #                     sendParallel=True, 
    #                     sendTcpIp=True, 
    #                     sendLogFile=True



    #%% ASYNC I - The GoNogo handler
    #
    #
    # When it comes to logging responses, this is the Soup Nazi-equivalent.
    # subjects should not press too soon, not too late, not twice, not the wrong side, etc etc.
    #
def init_gng(G):
        
    
    BUTTONS=G['v']['BUTTONS']
    GNGSPEED=G['v']['GNGSPEED']
    tooSoonTime=G['v']['tooSoonTime']
    AUDIOTONE_ERROR_COMMISSION=G['v']['AUDIOTONE_ERROR_COMMISSION']
    AUDIOTONE_STOP=G['v']['AUDIOTONE_STOP']
    
    
    G['S']=dict()
    G['S']['STOP']=1
    G['S']['GO']=0
    G['S']['BUTTONS'] = BUTTONS 
    G['S']['GNGSPEED'] = GNGSPEED

    
    
    # this is a list which basically acts as a pointer. From within functions 
    # we can change this as needed.
    G['S']['continueRoutine']=False # Container=[False]
    G['S']['goNogoStim'] = [None] # Container=[None]
    # nextfliptasks=[]
    G['S']['tooSoonTime'] = tooSoonTime
    G['S']['GNG_STOPPED'] = False
    
        
    # set up the staircase handler according specifications in Aron & Poldrack, 2009
    # ""Cortical and Subcortical Contributions to Stop Signal Response Inhibition: 
    # Role of the Subthalamic Nucleus""
    # 
    conditions = [
        {'label':'staircase1', 'startVal':100, 'stepSizes':-1.*50, 'nTrials':10, 'nUp':1, 'nDown':1, 'applyInitialRule':False, 'stepType':'lin'},
        {'label':'staircase2', 'startVal':150, 'stepSizes':-1.*50, 'nTrials':10, 'nUp':1, 'nDown':1, 'applyInitialRule':False, 'stepType':'lin'},
        {'label':'staircase3', 'startVal':200, 'stepSizes':-1.*50, 'nTrials':10, 'nUp':1, 'nDown':1, 'applyInitialRule':False, 'stepType':'lin'},
        {'label':'staircase4', 'startVal':250, 'stepSizes':-1.*50, 'nTrials':10, 'nUp':1, 'nDown':1, 'applyInitialRule':False, 'stepType':'lin'}
    ]
    G['S']['myMultiStairs'] = data.MultiStairHandler(stairType='simple', method='random', conditions=conditions, nTrials=40)
    
    
    # Obtain the Go Nogo Timing Parameters
    # for stop-signal task: read in the critucal timings from one of my 500 
    # OPTIMAL GLM Design specifications:
    tmp_rand_number = random.randint(1,193)
    
    
    timingsfile='gngtimings/newparam_%d.txt' % tmp_rand_number
    
    # log that, too.
    logging.data('GNG SELECTED LOGFILE: %s' % timingsfile)
    #timingsfile='gngtimings/tmpFile.txt'
    
    # we do these checks throughout.
    if __name__ != "__main__":
        timingsfile = os.path.join(os.path.dirname(os.path.realpath(__file__)),timingsfile)
    matrix=np.loadtxt(timingsfile)
    SSnumber, SSstopgo, ISIwaitTime, tmp1, tmp2, tmpLeftOrRight = zip(*matrix)
    
    # due to a discrepancy in my thinking, all are 0 (go) and 1 (stop), but I also wrote this for left or right in matlab.
    # but then I programmed it to make this look for 'left' and 'right'... so let's make this a new list:
    LeftOrRight=[]
    for item in tmpLeftOrRight:
        if item == 0:
            LeftOrRight.append('left')
        elif item == 1:
            LeftOrRight.append('right')
            
    LeftOrRight=tuple(LeftOrRight)
            
    
    G['S']['SSnumber']=SSnumber
    G['S']['SSstopgo']=SSstopgo
    G['S']['ISIwaitTime']=ISIwaitTime
    G['S']['LeftOrRight']=LeftOrRight
    
    
    
    
    
    # a rather convoluted way of dealing with this on late Friday with beer in sight:
    correctResponseSides=[]
    wrongResponseSides=[]
    for side in LeftOrRight:
        if side == 'left':
            correctResponseSides.append(BUTTONS[0])
            wrongResponseSides.append(BUTTONS[1])
        elif side == 'right':
            correctResponseSides.append(BUTTONS[1])
            wrongResponseSides.append(BUTTONS[0])
            
    G['S']['correctResponseSides']=correctResponseSides
    G['S']['wrongResponseSides']=wrongResponseSides
        
    # hmm, maybe this needs further investigation(s)... see above!
    G['S']['AUDIOTONE_ERROR_COMMISSION']=AUDIOTONE_ERROR_COMMISSION
    G['S']['AUDIOTONE_STOP']=AUDIOTONE_STOP
    
    
    
    
    G['S']['nextFlipTasks'] = []
    
    # handle the new clock..., so put the function handle into the struct too.
    # this is the MAIN clock...
    G['S']['clock']=clock.Clock()
    
    return(G)
    
    
def reset_clock(x):
    x['S']['clock'].reset()
    x['S']['continueRoutine'] = True
    


def init_reset_clock(G):
    G['S']['resetClock'] = reset_clock
    return(G)




# decorate this function...    
@asyncio.coroutine
def handle_gonogo(G):
    '''
    This contains the experimenal logic of the Stop Task. A lot of work
    went into constructing the stimuli. Stimuli parameters are loaded
    into variables in the code above. Runs 136 trials of Go-Nogo.
    This function is to be run within the asyncio loop.
    '''
 
    GNG_ARROWGOESRED=G['v']['GNG_ARROWGOESRED']
    GNG_ARROWGOESRED_DELAY=G['v']['GNG_ARROWGOESRED_DELAY']
    BUTTONS=G['S']['BUTTONS']
    snd_stopsignal=G['S']['snd_stopsignal']
    # we just need it here...
    STOP=1
    GO=0
    
    tooSoonTime = G['S']['tooSoonTime']  
    
    myMultiStairs = G['S']['myMultiStairs']
    
    
    DO_GNG = G['v']['DO_GNG']
    

    # if the time it took tov respond is smaller than this time --> invalid.
    numberOfResponses=0

    
    
    G['S']['nextFLipTasks']=[]  # stuff winflupper needs to do later on..

    vstimname_for_gng={'left':'al', 'right':'ar'}


    # not sure if this is easier for later. But it should make a dict that'll help
    # if ctrl-L is pressed, then Code = KeyL, ctrl-R is KeyR -- irrespective of what the keys were
    # set to (f.e. z=KeyL, and m=KeyR) -- should also work.
    KeyCodes = {G['S']['BUTTONS'][0]:'KeyL', G['S']['BUTTONS'][1]:'KeyR'}

    GNGSPEED = G['S']['GNGSPEED']
        
    
    # set the visual contents here...
    # INITIAL SETTING
    G['S']['goNogoStim']=G['vstims']['S']['fix']
    
    AUDIOTONE_STOP=G['S']['AUDIOTONE_STOP']
    AUDIOTONE_ERROR_COMMISSION=G['S']['AUDIOTONE_ERROR_COMMISSION']
    
    allGoReactionTimes=[]
    allGoReactionTimesLeft=[]
    allGoReactionTimesRight=[]

    
    allStopReactionTimes=[]
    allStopReactionTimesLeft=[]
    allStopReactionTimesRight=[]

  
    if DO_GNG:
        
        G['eh'].send_message('gonogo_BEGIN')
        
        
        # yeah, do all kinds of init here.
        for trialNumber in range(len(G['S']['SSstopgo'])):
    
    
            # this is wehre we're going wrong -- we don't need this, anymore, right?
            # thisDirection=random.choice(('al','ar')) # obtain this from the file!!
            leftorright=LorR = G['S']['LeftOrRight'][trialNumber]
            LorR = leftorright[0].upper()
            
            thisDirection = vstimname_for_gng[leftorright]
    
    
            thisTrialType_num = G['S']['SSstopgo'][trialNumber] # this is a 0 (GO) or 1 (STOP)
            thisTrialType = [GO, STOP][int(thisTrialType_num)]  # shady practices indeed -- so later on I cany say 'if this TrialType is GO:, etc'
            GorNG = ['Go', 'Stop'][int(thisTrialType)]
    
    
            thisISIWaitTime = G['S']['ISIwaitTime'][trialNumber]
            
            correctResponseSide = G['S']['correctResponseSides'][trialNumber]
            wrongResponseSide = G['S']['wrongResponseSides'][trialNumber]
            
            if thisTrialType is STOP:
                StopSignalHandled=False
                
    
            

            # allGoReactionTimes=[]
            # allStopReactionTimes=[]
            responded=False # subj responded?
            trialHandled=False
            responseHandled=False
            
            
            
            if thisTrialType is STOP:
                # this should be called only 40 times, since there are 40 stop trials...
                thisSSD, thisCondition = myMultiStairs.next() # I defined the myMultiStairs above.
            
    
    
            # this code tells the loop to only continue when continueTroutine is not False
            # otherwise it'll just keep yielding.
            # let winflipper make new clock
            G['S']['continueRoutine']=False
            G['S']['nextFlipTasks'].append([G['S']['resetClock'], G]) # the makeNewClock automatically makes things continue
            while G['S']['continueRoutine'] is False:
                yield From(asyncio.sleep(0))
            cl=G['S']['clock'] # obtain the clock that was just made.
    

            event.clearEvents() 
            allResponses=[] 
            # ok, we can proceed -- the clock has been set.
            G['S']['goNogoStim']=G['vstims']['S']['pre']
            while cl.getTime() < 0.5 * GNGSPEED:
                
                evs=event.getKeys(timeStamped=cl)
                # check if they press too SOON:
                if len(evs)>0 and not responded:
                    buttonsPressed, timesPressed = zip(*evs)
                    # it's highly unlikely that two buttons are pressed in a signle
                    # frame, but control for that anyway. by rule below.
                    allResponses.append((buttonsPressed[0], timesPressed[0]))
                    numberOfResponses += 1
                    responded=True
                    buttonPressed, RTime = allResponses[0]
                    # LOG this event... (i.e. send trigger)

                    # G['eh'].send_message('PressedTooSoon')
                    responseHandled=True
                    trialHandled=True
                    trialOutcome='PressedTooSoon'
                    
                    for button in buttonsPressed:
                        print button
                        if button in KeyCodes.keys():
                            G['eh'].send_message(KeyCodes[button])
                        else:
                            G['eh'].send_message('WrongKey')
                            
                    
                    
                yield From(asyncio.sleep(0))
        
        
    
    
    
        
            # obtain our next clock...
            # this code tells the loop to only continue when continueTroutine is not False
            # otherwise it'll just keep yielding.
            # let winflipper make new clock
            G['S']['continueRoutine']=False
            
            # make sure upon next window flow, we have a new clock set, and also - that marker is sent signalling the start of the new go/stop trial.
            G['S']['nextFlipTasks'].append([G['S']['resetClock'], G]) # the makeNewClock automatically makes things continue
            # send the trigger regarding the arrow, as soon as the windows flips
            G['S']['nextFlipTasks'].append([G['eh'].send_message, 'Begin' + GorNG + LorR])
            logging.data('Begin' + GorNG + LorR)
            while G['S']['continueRoutine'] is False:
                yield From(asyncio.sleep(0))
            cl=G['S']['clock'] # obtain the clock that was just made.
            
    
    
    
            # flush the even buffer here, otherwise we already have a response from before.
            event.clearEvents() 
            allResponses=[]
            TooManyResponses=False
            # ResponseTriggerTSent=False
            # this is where we show the arrow + find out whether a key is pressed:
            G['S']['goNogoStim']=G['vstims']['S'][thisDirection]
            currentTime = 0.0
            reactionTime = None
            ShowFix=False
            event.clearEvents()
            while currentTime < 1.0 * GNGSPEED:
                currentTime = cl.getTime()
                
                # set the stimulus to the proper direction (it's a choice, for now... -- but it's much much better to hard-code it)
                # make the arrow (+ circle)
    
                evs=event.getKeys(timeStamped=cl)
                
                
                if len(evs)>0:
                    ShowFix=True
                    if thisTrialType is STOP:
                        if AUDIOTONE_ERROR_COMMISSION is True:
                            snd_stopsignal.play()
                        
                
                # put this check also above and below -- then should be relatively done!!
                if len(evs)>0 and responded:   # important to do this FIRST
                    TooManyResponses=True
                
                
                if len(evs)>0 and not responded:
                    buttonsPressed, timesPressed = zip(*evs)
                    # it's highly unlikely that two buttons are pressed in a signle
                    # frame, but control for that anyway. by rule below.
                    allResponses.append((buttonsPressed[0], timesPressed[0]))
                    numberOfResponses += 1
                    responded=True
                    ShowFix=True
                    buttonPressed, RTime = allResponses[0]
                    # LOG this event... (i.e. send trigger)


                # once a button is pressed -- display fixation point again.
                if responded and not responseHandled:
                    responseHandled=True
                    # 'clear' the visual window --> fixation cross, again:
                    G['S']['goNogoStim']=G['vstims']['S']['fix']

                    
                    if RTime < tooSoonTime:
                        trialHandled=True
                        trialOutcome='PressedTooSoon'
                    else:
                        # ResponseTriggerTSent=True
                        if buttonsPressed[0] == BUTTONS[0]:
                            G['eh'].send_message('RespL')
                            logging.data('RespL, RT = %.6f' % (RTime))
                        elif buttonsPressed[0] == BUTTONS[1]:
                            G['eh'].send_message('RespR')
                            logging.data('RespR, RT = %.6f' % (RTime))
                        reactionTime = timesPressed[0]

                # do this anyway.
                if len(evs)>0:
                    for button in buttonsPressed:
                        if button in KeyCodes.keys():
                            G['eh'].send_message(KeyCodes[button])
                        else:
                            G['eh'].send_message('WrongKey')

                            
                if ShowFix:
                    if thisTrialType is STOP and responded and GNG_ARROWGOESRED:
                        if currentTime - RTime < GNG_ARROWGOESRED_DELAY: # show red for a whilethisSSD/1000. < 
                            G['S']['goNogoStim']=G['vstims']['S'][thisDirection+'r']
                            # pass
                        else:
                            G['S']['goNogoStim']=G['vstims']['S']['fix'] 
                    else:
                        G['S']['goNogoStim']=G['vstims']['S']['fix']    
    
        
                # what happens when a signal needs to be presented that it is a stop trial?
                # if it's a stop trial, then make arrow red after X time
                if thisTrialType is STOP and currentTime > thisSSD/1000.:
                                
                    if AUDIOTONE_STOP is True and not StopSignalHandled:
                        snd_stopsignal.play()
                        StopSignalHandled=True
        
                    if not ShowFix:
                        if not responded and GNG_ARROWGOESRED is True:
                            G['S']['goNogoStim']=G['vstims']['S'][thisDirection+'r']
                        else:
                            G['S']['goNogoStim']=G['vstims']['S'][thisDirection]
                
                # here we let the screen flip, for example...
                yield From(asyncio.sleep(0))
    
            
            # so the loop is done -- let's figure out what kind of trial this was.
            # taking care of the button press itself, as soon as button is pressed:
            if not trialHandled and responded:
                # print correctResponseSide
                # print buttonPressed
    
                trialHandled=True
    
                if TooManyResponses:
                    trialOutcome = 'TooManyResponses'
                    if thisTrialType is STOP:
                        myMultiStairs.addResponse(0)
    
                else:
                    if RTime < tooSoonTime:
                        trialOutcome = 'PressedTooSoon'
                        if thisTrialType is STOP:
                            myMultiStairs.addResponse(0)
                    else:
                        if thisTrialType is STOP:
                            
                            if buttonPressed == correctResponseSide:
                                trialOutcome = 'ErrorCommission'
                                myMultiStairs.addResponse(0)
        
                            elif buttonPressed == wrongResponseSide:
                                trialOutcome = 'WrongSideErrorCommission'
                                myMultiStairs.addResponse(0)
                                
                            
                        elif thisTrialType is GO:
                            if buttonPressed == correctResponseSide:
                                trialOutcome = 'CorrectGo'+LorR
    
                                # not yet...
                            elif buttonPressed == wrongResponseSide:
                                trialOutcome = 'WrongSideGo'
    
    
        
            # handle the 'response' if the button was NOT pressed:
            if not trialHandled and not responded:
                trialHandled = True
    
                if thisTrialType is GO:
                    trialOutcome = 'ErrorOmission'
    
                if thisTrialType is STOP:
                    trialOutcome = 'CorrectStop'+LorR
                    myMultiStairs.addResponse(1)

            
    
            # this code tells the loop to only continue when continueTroutine is not False
            # otherwise it'll just keep yielding.
            # let winflipper make new clock
    
    
            # this code tells the loop to only continue when continueTroutine is not False
            # otherwise it'll just keep yielding.
            # let winflipper make new clock
            G['S']['continueRoutine']=False
            G['S']['nextFlipTasks'].append([G['S']['resetClock'], G]) # the makeNewClock automatically makes things continue
            while G['S']['continueRoutine'] is False:
                yield From(asyncio.sleep(0))
            cl=G['S']['clock'] # obtain the clock that was just made.
    
    
    
            # print('final one')
            # ok, we can proceed -- the clock has been set.
            flushed=False
            G['S']['goNogoStim']=G['vstims']['S']['fix']
            event.clearEvents()
            while cl.getTime() < thisISIWaitTime * GNGSPEED:
                if not flushed:
                    # this is a nice place to save it to logfile: before the 
                    # send a report about the STOP trial, write a nice line:
                    # logging.data('messa')
                    logging.flush()
                    flushed=True
                    
                evs=event.getKeys(timeStamped=cl)
                                # do this anyway.
                if len(evs)>0:
                    buttonsPressed, timesPressed = zip(*evs)
                    for button in buttonsPressed:
                        buttonsPressed, timesPressed = zip(*evs)
                        trialOutcome='PressedTooLate'
                        if button in KeyCodes.keys():
                            G['eh'].send_message(KeyCodes[button])
                            logging.data('Response: %s' % (KeyCodes[button]))
                        else:
                            G['eh'].send_message('WrongKey')


                yield From(asyncio.sleep(0))

                                    
            # so we send it out the Final Verdict!
            G['eh'].send_message(trialOutcome)
            logging.data(trialOutcome)
            
            # Store the reaction time, too:
            # get the Stop Time - from staircase:
            if trialOutcome == 'CorrectGoL':
                allGoReactionTimesLeft.append(reactionTime)
                allGoReactionTimes.append(reactionTime)
            elif trialOutcome == 'CorrectGoR':
                allGoReactionTimesRight.append(reactionTime)
                allGoReactionTimes.append(reactionTime)
            elif trialOutcome == 'CorrectStopL':
                allStopReactionTimesLeft.append(thisSSD)
                allStopReactionTimes.append(thisSSD)
            elif trialOutcome == 'CorrectStopR':
                allStopReactionTimesRight.append(thisSSD)
                allStopReactionTimes.append(thisSSD)

            print(trialNumber)

        try:
            # log all the RT's:
            logging.data('All Go Reaction Times of Correct Trials')
            for item in allGoReactionTimesLeft:
                logging.data('RT %s: %.6f' % ('L', item))
            for item in allGoReactionTimesRight:
                logging.data('RT %s: %.6f' % ('R', item))
    
                
            logging.data('All Stop SSDs of Correct Trials')
            for item in allStopReactionTimesLeft:
                logging.data('SSD %s: %.6f' % ('L', item))
            for item in allStopReactionTimesRight:
                logging.data('SSD %s: %.6f' % ('R', item))
                
    
            # all:
            SSD = np.mean(allStopReactionTimes)
            RTGO = np.median(allGoReactionTimes)
            SSRT = RTGO - SSD/1000.
            
            # left:
            SSDL = np.mean(allStopReactionTimesLeft)
            RTGOL = np.median(allGoReactionTimesLeft)
            SSRTL = RTGOL - SSDL/1000.
            
            
            # right:
            SSDR = np.mean(allStopReactionTimesRight)
            RTGOR = np.median(allGoReactionTimesRight)
            SSRTR = RTGOR - SSDR/1000.
    
            logging.data('Mean SSD: %.6f\tMedian RT: %.6f\tSSRT = %.6f' % (SSD, RTGO, SSRT))
            print('Mean SSD: %.6f\tMedian RT: %.6f\tSSRT = %.6f' % (SSD, RTGO, SSRT))
            
            logging.data('Mean SSDL: %.6f\tMedian RTL: %.6f\tSSRTL = %.6f' % (SSDL, RTGOL, SSRTL))
            print('Mean SSDL: %.6f\tMedian RTL: %.6f\tSSRTL = %.6f' % (SSDL, RTGOL, SSRTL))
            
            logging.data('Mean SSDR: %.6f\tMedian RTR: %.6f\tSSRTR = %.6f' % (SSDR, RTGOR, SSRTR))
            print('Mean SSDR: %.6f\tMedian RTR: %.6f\tSSRTR = %.6f' % (SSDR, RTGOR, SSRTR))
            
            logging.flush()
        except:
            print('something went wrong here.')
        
    
    
    if DO_GNG:
        G['eh'].send_message('gonogo_END')
    
    
    # tell the visual to stop flipping, allowing visual to end their part of the async loop:
    G['S']['GNG_STOPPED'] = True
            # print(trialNumber)    
            
        # yield From(asyncio.sleep(0))
        # the stop task should be finished now!
        # the visual task should also be finished around the same time.
        # so further stuff, we can do with basic instructions, wait times, etc
        # print('finished, escaped from the loop!') 



#%% ASYNC II - The Audio Handler

# the audio stim list:
# audio_stim_list = [[10.,20.,'audio',['left','40']],[112.5,130.,'audio',['left','40']],[242.5,260.,'audio',['left','40']],[50.,60.,'audio',['left','55']],[195.,205.,'audio',['left','55']],[312.5,330.,'audio',['left','55']],[30.,40.,'audio',['right','40']],[147.5,165.,'audio',['right','40']],[277.5,295.,'audio',['right','40']],[77.5,95.,'audio',['right','55']],[175.,185.,'audio',['right','55']],[215.,225.,'audio',['right','55']]]

# make a more usable stim list:
        
def init_audio(G):
    
    audio_stim_list = [
            [10.0, 20.0, 'aud_l40'],
            [112.5, 130.0, 'aud_l40'],
            [242.5, 260.0, 'aud_l40'],
            [50.0, 60.0, 'aud_l55'],
            [195.0, 205.0, 'aud_l55'],
            [312.5, 330.0, 'aud_l55'],
            [30.0, 40.0, 'aud_r40'],
            [147.5, 165.0, 'aud_r40'],
            [277.5, 295.0, 'aud_r40'],
            [77.5, 95.0, 'aud_r55'],
            [175.0, 185.0, 'aud_r55'],
            [215.0, 225.0, 'aud_r55']
            ]
    
    # load in the audio's timings, defined in seconds, so that later on, one could
    # input triggers into the EEG (or optionally -- send out triggers with the event handler)        
    
    # 40 Hz:
    
    stimsdir='stims'
    if __name__ != "__main__":
        stimsdir = os.path.join(os.path.dirname(os.path.realpath(__file__)),stimsdir)
    
    timings40Hz=np.loadtxt(os.path.join(stimsdir, 'audio_40_ts.txt'));
    # 50 Hz:
    timings55Hz=np.loadtxt(os.path.join(stimsdir, 'audio_55_ts.txt'))
    
    # see also the figure_out_audio_timings.m file to further play with the audio's
    # waveforms.
    
    
    snd40hzL = sound.backend_pygame.SoundPygame(value=os.path.join(stimsdir, 'audio_40Hz_L.wav'),loops=0)
    snd40hzR = sound.backend_pygame.SoundPygame(value=os.path.join(stimsdir, 'audio_40Hz_R.wav'),loops=0)
    snd55hzL = sound.backend_pygame.SoundPygame(value=os.path.join(stimsdir, 'audio_55Hz_L.wav'),loops=0)
    snd55hzR = sound.backend_pygame.SoundPygame(value=os.path.join(stimsdir, 'audio_55Hz_R.wav'),loops=0)
    
    snd_stopsignal = sound.backend_pygame.SoundPygame(value=900,secs=0.5,loops=0)
    
    
    astims={
            'aud_l40':snd40hzL,
            'aud_r40':snd40hzR,
            'aud_l55':snd55hzL,
            'aud_r55':snd55hzR
            }
    
    
    # put these into the variable, too...
    G['astims']=astims
    G['A']=dict()
    G['A']['audio_stim_list']=audio_stim_list
    G['A']['timings40Hz']=timings40Hz
    G['A']['timings55Hz']=timings55Hz
    G['S']['snd_stopsignal']=snd_stopsignal
    
    return(G)


@asyncio.coroutine
def handle_audio(G):
    '''
    this should handle the audio stimuli, using the async programming style.
    it starts a new clock and depending on timings, will start some audio
    samples, L or R, 40 or 55 Hz.
    '''
    
    
    audio_stim_list =  G['A']['audio_stim_list']
    astims = G['astims']
    eh=G['eh']

    DO_AUDIO = G['v']['DO_AUDIO']
    
    
    audioClock=clock.Clock()
    playing=False
    withinAudioBlock=False
    prevWithinAudioBlock=False
    # RunAudio=True
    
    
    currentTime=audioClock.getTime()
    
    if DO_AUDIO:
        logging.data('aud_BEGIN')
        eh.send_message('aud_BEGIN')
    # just before going in here -- LOG it.
    # log the beginning...
    
    while currentTime < 340.: #currentTime < 340.:
        

        if DO_AUDIO:
            # print('hello')
            # print(currentTime)
            
            if not playing:     # I can safely use this since only one audio is playing at a time.
    
                withinAudioBlock=False
                
                for item in audio_stim_list:
                    b, e, stim = item
                    if b < currentTime < e:
                        currentStim = stim
                        withinAudioBlock=True
                        astims[stim].play()
                        playDuration=astims[stim].getDuration()
                        playing=True
                        playClock=clock.Clock()
                        
                        # print(stim)
                        logging.data(stim)
                        eh.send_message(stim)
                        logging.flush()
    
                        
            else:
                if playClock.getTime() > playDuration:  # figure out if something is playing 
                    playing=False
    
                    
            # try dealing with begin and ending markers:                    
            if withinAudioBlock and not prevWithinAudioBlock:
                messg=currentStim.replace('_','_b')
                # print(messg)
                logging.data(messg)
                eh.send_message(messg)
                prevWithinAudioBlock=True
                
            elif prevWithinAudioBlock and not withinAudioBlock:
                messg=currentStim.replace('_','_e')
                # print(messg)
                logging.data(messg)
                eh.send_message(messg)
                prevWithinAudioBlock=False
                
            
        # this will stop this loop, probably:
        currentTime=audioClock.getTime()
        #if currentTime > 340.:
        #    print('Stopping!')
        #    RunAudio=False
            
        yield From(asyncio.sleep(0))  # pass control to someone else, while this guy sleeps a bit.
            
    if DO_AUDIO:        
        logging.data('aud_END')
        eh.send_message('aud_END')




#%% ASYNC III - The Visual handler
## set up the functions to be used in the end for asyncing through the loops:
# load the vis table somewhere here - big mem space (.csv?)
    

# so, instead of loading in a separate frame-by-frame list; define a function that as output has this list.


    
def init_visual(G):
    

    VIS_SHOWOPPOSITE=G['v']['VIS_SHOWOPPOSITE']
    VIS_checkerSpeedMultiplier=G['v']['VIS_checkerSpeedMultiplier']
    FPS=G['v']['MONITOR_FPS']
    # load in the table that tells me all the stop signal stuff (.csv?)
    #% Frame-by-frame checkerboard List
    # load in the frame-list of the visual stimuli: i.e. saying when things should
    # be used:
    G['V']=dict()
    G['V']['ASYNC_SLEEPTIME'] = 1./FPS*0.75        
    
    
    #with open('efl/fd.pkl','rb') as f:
    #    fd=pickle.load(f)
    #    
    #
    #with open('efl/complete_fd_list.pkl','rb') as f:
    #    complete_fd_list=pickle.load(f)
    #
    ##    with open('efl/fd_with_markers.pkl','rb') as f:
    ##        fd_with_markers=pickle.load(f)
    #    
    #with open('efl/fd_with_markers_III.pkl','rb') as f:
    #    fd_with_markers=pickle.load(f)
    
    
    # this is SUPER important!! Here, the frame-by-frame list is generated.
    
    fd_with_markers = visualHelper.convert_to_fd_vis(FPS=60.,VIS_SHOWOPPOSITE=VIS_SHOWOPPOSITE, VIS_checkerSpeedMultiplier=VIS_checkerSpeedMultiplier)
    
    G['V']['fd_with_markers']=fd_with_markers
    
     
    ISIwaitTime=G['S']['ISIwaitTime']
    extra_Time = sum(ISIwaitTime)+len(ISIwaitTime)*1.5 - len(fd_with_markers)/FPS
    
    return(G)
    
    


@asyncio.coroutine
def handle_visual(G):
    '''
    This flips the window, draws the stuff to be drawn, and calls
    functions to be called from the stop task. It is supposed to be
    run in the asyncio loop.
    '''
    
    # logging.console.setLevel(logging.DEBUG)
    # mainClock=G['mainClock']
    win=G['win']
    
    eh=G['eh']
    fd_with_markers=G['V']['fd_with_markers']
    
    
    ASYNC_SLEEPTIME=G['V']['ASYNC_SLEEPTIME']
    
    DO_VISUAL = G['v']['DO_VISUAL']
    
    # print ASYNC_SLEEPTIME
    
    frameCounter=0
    vstims=G['vstims']['V']

    totFrames=len(fd_with_markers)
    print(totFrames)

    # visualClock=clock.Clock()
    # this will run the entire length of the visual...
    # within this time, the stop signal task will (hopefully) finish.
    # OR... we can also just use a counter.
    
    if DO_VISUAL:
        eh.send_message('vis_BEGIN')
    
    # the visual task...
    while frameCounter < totFrames:
    
    
        # the workflow
        # 1) Prepare everything + draw
        # 2) Prepare markers
        # 3) win.flip() + the callOnFlip routines to be done.
    
        
        # all the visual stuff:
        frameIndex, visContents, markers = fd_with_markers[frameCounter]
        
        
        
        
        frameCounter += 1
        # deal with the visuals -- using vstims which should be accessible
        # we get the list...
        # create the shapes to be drawn using list comprehension
        
        shapes=[]
        
        if DO_VISUAL:
            if len(visContents) > 0:
                for item in visContents:
                    for stim in vstims[item]:
                        shapes.append(stim)


        # print shapes
        
        # print G['S']['goNogoStim']
        
        # add the gonogo stimuli to them:
        if len(G['S']['goNogoStim'])>0:
            for stim in G['S']['goNogoStim']:
                if stim is not None:
                    shapes.append(stim)
            
        
        # print shapes
        
        # draw them on our little canvas.
        if len(shapes)>0:
            for shape in shapes:
                #if shape is not None:
                shape.draw()
        else:
            G['vstims']['S']['fix'][0].draw()
            


        # prepare the calls for the next iteration, including marlers;
        # deal with visual markers
        if DO_VISUAL:
            if len(markers) > 0:
                for marker in markers:
                    win.callOnFlip(eh.send_message,'vis_'+marker)
                    # win.callOnFlip(print,marker)
        
        
        # this is to ensure that the GNG still is operational.
        tasks=G['S']['nextFlipTasks']
        while len(tasks) > 0:
            task=tasks.pop(0)
            function, arg = task
            win.callOnFlip(function, arg)


        # we flip the screen here - this will take ~ 16.66667 msec.
        win.flip()
        yield From(asyncio.sleep(0))
        

    if DO_VISUAL:   
        eh.send_message('vis_END')
    

    extra_frame_counter=0
    while G['S']['GNG_STOPPED'] is False:
        
        
        extra_frame_counter += 1
        shapes=[]
        # add the gonogo stimuli to them:
        if len(G['S']['goNogoStim'])>0:
            for stim in G['S']['goNogoStim']:
                if stim is not None:
                    shapes.append(stim)
            
        
        
        # draw them on our little canvas.
        if len(shapes)>0:
            for shape in shapes:
                #if shape is not None:
                shape.draw()
        else:
            G['vstims']['S']['fix'][0].draw()
            
            
        # this is to ensure that the GNG still is operational.
        tasks=G['S']['nextFlipTasks']
        while len(tasks) > 0:
            task=tasks.pop(0)
            function, arg = task
            win.callOnFlip(function, arg)
        
        
        # we flip the screen here - this will take ~ 16.66667 msec.
        win.flip()
        yield From(asyncio.sleep(0))
        
        
        # sleep for a little while - hope this actually works
        
                
        # do for loop for TIME (I suppose)
        
        # check vis table + draw stimuli
        # if there's an event - send to sync
        
        # check stimulus for stop + draw stimuli
        
        # pass on current time for audio presentation (this is another process)
        
        # AWAIT (!) -- to flip the window
    






#%% ASYNC IV - The Main Event Loop


# a test coroutine in order to check our debugging...            
@asyncio.coroutine
def test_it(G):
    cl=clock.Clock()
    # while cl.getTime() < 1: #i in range(1000):e
    runit=True
    while runit:
        print cl.getTime()
        yield From(asyncio.sleep(0))
    
        if cl.getTime() > 1:
            runit=False
        if cl.getTime() > 0.5:
            #pass
            print(1/0)
    
# a special exception handler coroutine that'll kill our main loop if something
# happens
@asyncio.coroutine
def handle_exception(f, G, loop):
    print f
    print loop
    try:
        yield From(f(G))
    except Exception:
        # print debug information
        print('---------------')
        print('---------------')
        print('ERROR OCCURRED:')
        print(sys.exc_info()[1])
        traceback.print_tb(sys.exc_info()[2])

        # G['eh'].shutdown()
        # G['eh'].join()
        # G['win'].close()
        # logging.flush()


        pending = asyncio.Task.all_tasks()
        for task in pending:
            task.cancel()
            # Now we should await task to execute it's cancellation.
            # Cancelled task raises asyncio.CancelledError that we can suppress:
            #with suppress(asyncio.CancelledError):
            #    loop.run_until_complete(task)        
        loop.stop()  # stops the loop, gives an error for that, too.




def run_main_loop(G):
    '''
    This runs the stopingibition/visual/audio part of the paradigm using
    asyncio-replacement trollius. Before and after, we can still present
    other stimuli.
    '''
    
    
    # something like this:
    # mainClock=clock.Clock()
    # mainClockContainer[0]=mainClock # put it into my list, that double-serves
                                    # as a pointer
    
    
    
    loop=asyncio.new_event_loop()
    asyncio.set_event_loop(loop)
    #tasks = [
    #    asyncio.async(handleVisual()),
    #    asyncio.async(handleGonogo()),
    #    asyncio.async(handleEscape()),
    #    ]
    tasks_dbg = [
            # asyncio.async(handle_exception(test_it,G,loop)),
            asyncio.async(handle_exception(handle_audio,G,loop)),
            asyncio.async(handle_exception(handle_visual,G,loop)),
            asyncio.async(handle_exception(handle_gonogo,G,loop)),
            #asyncio.async(handle_exception(handle_visual,loop)),
            
            ]
    
    
    tasks = [
            # asyncio.async(test_it(G)),
            # asyncio.async(handle_audio(G))
            ]
    
    # so to debug, just run tasks_dbg instead of tasks.
    loop.run_until_complete(asyncio.wait(tasks_dbg))   
    loop.close()
    #  close down our little Process, or it'll become a Zombie.



#%% Pre and Post Functions:


def wait_for_key(G):
    event.clearEvents()
    win=G['win']
    eh=G['eh']
    
    testinstr=visual.TextStim(win, 'Wait a moment...',pos=(0, 0), units='norm')
    incor_clock=clock.Clock()
    correctlyPressed=False
    drawIncorrect=False
    
    while not correctlyPressed:
        testinstr.draw()
        if drawIncorrect is True and incor_clock.getTime() < 1.0:
            incorr_str.draw()
        else:
            drawIncorrect=False
        win.flip()

                
        evs=event.getKeys(timeStamped=incor_clock)
        if len(evs) > 0:
            buttonsPressed, timesPressed = zip(*evs)
            buttonPressed=buttonsPressed[0]
            if buttonsPressed[0] in G['v']['STARTKEYS']:
                correctlyPressed=True
            else:
                INCORRECT_TEXT='One moment of patience..  (You pressed: %s)' % (buttonPressed)
                incorr_str = visual.TextStim(win, INCORRECT_TEXT,pos=(0, -0.5), units='norm')
                drawIncorrect=True
                incor_clock.reset()
                        
    
def test_buttons(G):
    # check buttons
    event.clearEvents() 
    win=G['win']
    INSTR=G['v']['INSTR']
    eh=G['eh']
    BUTTONS=G['v']['BUTTONS']
    TEXT=['Test: Press the left (L) button','Test: Press the right (R) button']
    testinstr=[visual.TextStim(win, TEXT[0],pos=(0, 0.5), units='norm'), visual.TextStim(win, TEXT[1],pos=(0, 0.5), units='norm')]
    testarrows = [G['vstims']['S']['al'][2], G['vstims']['S']['ar'][2]]
    

    for i, side in enumerate(['L','R']):
        incor_clock=clock.Clock()
        correctlyPressed=False
        drawIncorrect=False
        while not correctlyPressed:
            testinstr[i].draw()
            testarrows[i].draw()
            if drawIncorrect is True and incor_clock.getTime() < 1.0:
                incorr_str.draw()
            else:
                drawIncorrect=False
                
            win.flip()
    
            evs=event.getKeys(timeStamped=incor_clock)
            if len(evs) > 0:
                buttonsPressed, timesPressed = zip(*evs)
                buttonPressed=buttonsPressed[0]
                if buttonsPressed[0] == BUTTONS[i]:
                    correctlyPressed=True
                else:
                    
                    INCORRECT_TEXT='That was not the correct button! You pressed: %s' % (buttonPressed)
                    incorr_str = visual.TextStim(win, INCORRECT_TEXT,pos=(0, -0.5), units='norm')
                    drawIncorrect=True
                    incor_clock.reset()
                

    contstim=visual.TextStim(win, 'Press to continue...',pos=(0.0, 0.90), height=0.08, units='norm')
    # startstim=visual.TextStim(win, 'Press to Start!',pos=(0.0, 0.0), height=0.12, units='norm')
    contstim.draw()
    win.flip()
    event.waitKeys()



def instr_screen0(G):
    
    event.clearEvents() 
    win=G['win']
    INSTR=G['v']['INSTR']
    eh=G['eh']

    fstim=visual.TextStim(win, 'Please keep your fingers on the buttons throughout the experiment.',pos=(0.0, 0.0), height=0.12, units='norm')
    # fstim=visual.TextStim(win, 'Press to continue with Eyes Open / Eyes Closed...',pos=(0.0, 0.0), height=0.12, units='norm')
    contstim=visual.TextStim(win, 'Press to continue...',pos=(0.0, 0.90), height=0.08, units='norm')
    contstim2=visual.TextStim(win, 'with Eyes Open / Eyes Closed...',pos=(0.0, 0.81), height=0.08, units='norm')
    fstim.draw()
    contstim.draw()
    contstim2.draw()
    win.flip()
    event.waitKeys()
        

def instr_screen(G):
    
    
    event.clearEvents() 
    win=G['win']
    INSTR=G['v']['INSTR']
    eh=G['eh']
    # BUTTONS=G['v']['BUTTONS']
    contstim=visual.TextStim(win, 'Press to continue...',pos=(0.0, 0.90), height=0.08, units='norm')
    startstim=visual.TextStim(win, 'Press to Start!',pos=(0.0, 0.0), height=0.12, units='norm')
    
    # INSTR='Remember, respond as FAST as you can once you see the arrow.\n\n'+'However, if you hear a beep, your task is to STOP yourself '+'from pressing.\n\n'+'Stopping and Going are equally important.'
    instr1=visual.TextStim(win, INSTR)
    contstim.draw()
    instr1.draw()

    win.flip()
    event.waitKeys()


    startstim.draw()
    win.flip()
    event.waitKeys()




def eo_stim(G):
    
    EYESCLOSED_TIME=G['v']['EYESCLOSED_TIME']
    win=G['win']
    eh=G['eh']
    incor_clock=clock.Clock()
    contstim=visual.TextStim(win, 'Press to continue...',pos=(0.0, 0.90), height=0.08, units='norm')
    ecstim = visual.TextStim(win, 'Eyes open',pos=(0.0, 0.0), height=0.12, units='norm')
    

    ecstim.draw()
    win.flip()
    eh.send_message('eo_BEGIN')
    incor_clock=clock.Clock()
    while incor_clock.getTime()<float(EYESCLOSED_TIME):
        ecstim.draw()
        win.flip()
    eh.send_message('eo_END')
    



def ec_stim(G):
    
    snd_endeyesclosed = sound.backend_pygame.SoundPygame(value=391,secs=0.8,loops=0)
    snd_endeyesclosed.volume=0.5
    EYESCLOSED_TIME=G['v']['EYESCLOSED_TIME']
    win=G['win']
    eh=G['eh']
    incor_clock=clock.Clock()  # this is so dirty coding, terrible!
    contstim=visual.TextStim(win, 'Press to continue...',pos=(0.0, 0.90), height=0.08, units='norm')
    ecstim = visual.TextStim(win, '... Close your eyes',pos=(0.0, -0.1), height=0.12, units='norm')
    ecstim.draw()
    win.flip()
    incor_clock.reset()
    while incor_clock.getTime()<3.0:
        pass
    eh.send_message('ec_BEGIN')
    # win.
    win.color=[-1.,-1.,-1.]
    win.flip()
    win.flip()
    incor_clock.reset();

    while incor_clock.getTime()<float(EYESCLOSED_TIME):
        win.flip()
    
    
    eh.send_message('ec_END')
    snd_endeyesclosed.play()
    for i in range(5):
        win.color=[1, 1, 1]
        win.flip()
        win.flip()
        time.sleep(0.2)
        win.color=[-1, -1, -1]
        win.flip()
        win.flip()
        time.sleep(0.2)
        

        
    win.color=[0, 0, 0] 
    win.flip()
    win.flip()
        

    

def end_task(G):

    win=G['win']
    endstim = visual.TextStim(win, 'Task Ended; Press to exit!',pos=(0.0, 0.0), height=0.12,units='norm')
    contstim=visual.TextStim(win, 'Press to continue...',pos=(0.0, 0.90), height=0.08, units='norm')
    
    endstim.draw()
    contstim.draw()
    win.flip()
    event.clearEvents()
    event.waitKeys()
    
    # shutting down the event handler, too. Otherwise, it'd be best to leave it open!
    G['eh'].shutdown()        
    G['eh'].join()
    
    
    
    # the following is repeated logic -- but effective
    # check whether there's another logfile - in log directory
    # make efl_triggers version of it, too.
    filename='log/framelog.pkl'
    logdir=os.path.dirname(filename)
    
    if __name__ != "__main__":
        logdir = os.path.join(os.path.dirname(os.path.realpath(__file__)),logdir)
    
    logbasename, ext = os.path.splitext(os.path.basename(filename))
    
       
    # figure out if there's a log directory, if not --> make it:
    if not os.path.exists(logdir):
        os.makedirs(logdir)
    
    # figure out which files reside within this logfile directory:
    if len(glob.glob(logdir + os.sep + logbasename + "*" + ext)) == 0:
        logcounter=0
    else:
        # figure out biggest number:
        matches=[match for match in [re.match(logbasename+'([0-9]*)'+ext,item) for item in os.listdir(logdir)]]
        newlist=[]
        for match in matches:
            if match is not None:
                newlist.append(match.group(1))
        logcounter = max([int(n) for n in newlist])
    
    # so make just another logfile on top of this one -- it'll be timestamped    
    logcounter += 1
    
    # this is the new logfile:
    newFrameLogFile=os.path.join(logdir,logbasename+'%d'%logcounter + ext )
    
    
    
    with open(newFrameLogFile,'wb') as f:
        pickle.dump(G['win'].frameIntervals, f)
        
    print('written logfile regarding the frame intervals, too.')
    
    win.flip()




def measure_artifact_program(G):
    
    
    
    win=G['win']
    eh=G['eh']
    
    cl=clock.Clock()
    t1=visual.TextStim(win, 'Try to follow jumping/moving crosshair, without moving your head',pos=(0.0, 0.0), height=0.12,units='norm')
    cl.reset()
    while cl.getTime() < 4.0:
        t1.draw()
        win.flip()
        
    
    a=visual.TextStim(win, '+',pos=(0.0, 0.0), height=0.12,units='norm')
        
    
    cl.reset()
    while cl.getTime() < 1.5:
        win.flip()



    # do the saccades...
    def move_a_fast(pos, msg, a):
        a.pos=pos
        cl.reset()
        eh.send_message(msg)
        while cl.getTime() < 2.2: #2.2:
            a.draw()
            win.flip()
        
        
        # 'h4l','h4r','h8l','h8r','v4u','v4d','v8u','v8d', 'c', 'hvest','hvestp','vvest','vvestp','blinks','neck','jaw'

    # horizontal...
    positions = [(0, 0, 'c'), (-0.4, 0, 'h4l'), (0.4, 0, 'h4r'), (-0.4, 0, 'h4l'), (0.4, 0, 'h4r'), (-0.8, 0, 'h8l'), (0.8, 0, 'h8r'), (-0.8, 0, 'h8l'), (0.8, 0, 'h8r'), 
                              (-0.4, 0, 'h4l'), (0.4, 0, 'h4r'), (-0.4, 0, 'h4l'), (0.4, 0, 'h4r'), (-0.8, 0, 'h8l'), (0.8, 0, 'h8r'), (-0.8, 0, 'h8l'), (0.8, 0, 'h8r'),
                 (0, 0, 'c'), (0, -0.4, 'v4d'), (0, 0.4, 'v4u'), (0, -0.4, 'v4d'), (0, 0.4, 'v4u'), (0, -0.8, 'v8d'), (0, 0.8, 'v8u'), (0, -0.8, 'v8d'), (0, 0.8, 'v8u'), 
                              (0, -0.4, 'v4d'), (0, 0.4, 'v4u'), (0, -0.4, 'v4d'), (0, 0.4, 'v4u'), (0, -0.8, 'v8d'), (0, 0.8, 'v8u'), (0, -0.8, 'v8d'), (0, 0.8, 'v8u'), ]
                 
    for p in positions:
        x, y, msg = p
        move_a_fast((x, y), msg, a)
    
    
    
    
    def move_a_slow(b, e, msg, a):
        # set pos a first..
        a.pos=b
        cl.reset()
        eh.send_message(msg)

        tmax = 3.0        
        if msg == 'hvestp' or msg == 'vvestp':
            tmax = 1.5

        currentTime=0.0
        while currentTime < tmax:
            currentTime=cl.getTime()
            
            totx = e[0] - b[0]
            toty = e[1] - b[1]
            
            dx = b[0] + currentTime / tmax * totx
            dy = b[1] + currentTime / tmax * toty
            
            a.pos = (dx, dy)
            a.draw()
            win.flip()
        
        
    # do the vestibulo stuff.
    slow_positions = [[(0, 0), (-0.8, 0), 'hvestp'], [(-0.8, 0), (0.8, 0), 'hvest'], [(0.8, 0), (-0.8, 0), 'hvest'], [(-0.8, 0), (0.8, 0), 'hvest'], [(0.8, 0), (0, 0), 'hvestp'],
                      [(0, 0), (0, -0.8), 'vvestp'], [(0, -0.8), (0, 0.8), 'vvest'], [(0, 0.8), (0, -0.8), 'vvest'], [(0, -0.8), (0, 0.8), 'vvest'], [(0, 0.8), (0, 0), 'vvestp'],
                      ]

    for sp in slow_positions:
        b, e, msg = sp
        move_a_slow(b, e, msg, a)


    cl.reset()
    while cl.getTime() < 1.5:
        win.flip()

                      
    # ask for eye blinks...
    t2=visual.TextStim(win, 'Blink 10 times (keep eyes on cross), ~ 1 second between blinks',pos=(0.0, 0.4), height=0.08,units='norm')
    a.pos=(0, 0)
    cl.reset()
    eh.send_message('eyeblinks')
    while cl.getTime() < 12.0:
        a.draw()
        t2.draw()
        win.flip()
        

    cl.reset()
    while cl.getTime() < 1.5:
        win.flip()
        

        
    
    # ask for tense of neck muchles
    t3=visual.TextStim(win, 'Tense your neck muscles (left) (4 seconds)',pos=(0.0, 0.0), height=0.12,units='norm')
    cl.reset()
    eh.send_message('neckl')
    while cl.getTime() < 4.0:
        t3.draw()
        win.flip()
        
    
    cl.reset()
    while cl.getTime() < 1.5:
        win.flip()

        

    # ask for tense of neck muchles
    t4=visual.TextStim(win, 'Tense your neck muscles (right) (4 seconds)',pos=(0.0, 0.0), height=0.12,units='norm')
    cl.reset()
    eh.send_message('neckr')
    while cl.getTime() < 4.0:
        t4.draw()
        win.flip()
        
        
    cl.reset()
    while cl.getTime() < 1.5:
        win.flip()

        
    # ask for tense of neck muchles
    t5=visual.TextStim(win, 'Tense your jaw muscles (clench teeth) (4 seconds)',pos=(0.0, 0.0), height=0.12,units='norm')
    cl.reset()
    eh.send_message('jaw')
    while cl.getTime() < 3.5:
        t5.draw()
        win.flip()

    
    cl.reset()
    while cl.getTime() < 1.5:
        win.flip()


    # ask for tense of neck muchles
    t6=visual.TextStim(win, 'Frown your eyebrows (4 seconds)',pos=(0.0, 0.0), height=0.12,units='norm')
    cl.reset()
    eh.send_message('eyebrows')
    while cl.getTime() < 4.0:
        t6.draw()
        win.flip()

    cl.reset()
    while cl.getTime() < 1.5:
        win.flip()
        
        
    # ask for tense of neck muchles
    t7=visual.TextStim(win, 'Swallow movement (once)..',pos=(0.0, 0.0), height=0.12,units='norm')
    cl.reset()
    eh.send_message('swallow')
    while cl.getTime() < 3.0:
        t7.draw()
        win.flip()        

    cl.reset()
    while cl.getTime() < 1.5:
        win.flip()


        
    # ask for tense of neck muchles
    t8=visual.TextStim(win, 'Thank you, we continue with main experiment!',pos=(0.0, 0.0), height=0.12,units='norm')
    cl.reset()
    while cl.getTime() < 3.5:
        t8.draw()
        win.flip()
        

    cl.reset()
    while cl.getTime() < 1.5:
        win.flip()









#%% Separate subroutine to start up the event handler:
    
    
    
def start_ev(G):
    
    
    EVENT_destip=G['v']['EVENT_destip']
    EVENT_destport=G['v']['EVENT_destport']
    EVENT_LPTTrigWaitTime=G['v']['EVENT_LPTTrigWaitTime']
    EVENT_sendParallel=G['v']['EVENT_sendParallel']
    EVENT_sendTcpIp=G['v']['EVENT_sendTcpIp']
    EVENT_LPTAddress=G['v']['EVENT_LPTAddress']
    EVENT_sendLogFile=G['v']['EVENT_sendLogFile']
    EVENT_printToTerminal=G['v']['EVENT_printToTerminal']
    EVENT_printToTerminalAllowed=G['v']['EVENT_printToTerminalAllowed']
    
    mainClock=G['mainClock']
    MSGDICT=G['evcodes']
    EVENT_TRIGLOG=G['EVENT_TRIGLOG']
    print('----')
    print(MSGDICT)
    print('EVENT_sendParallel is: ' + str(EVENT_sendParallel))
    print('----')
    
    eh=eventhandler.eventHandler(
        mainClock, 
        messagedict=MSGDICT,
        destip=EVENT_destip,
        destport=EVENT_destport,
        LPTAddress=EVENT_LPTAddress,
        LPTTriggerWaiting=EVENT_LPTTrigWaitTime,
        filename=EVENT_TRIGLOG,
        sendParallel=EVENT_sendParallel, 
        sendTcpIp=EVENT_sendTcpIp, 
        sendLogFile=EVENT_sendLogFile,
        printToTerminal=EVENT_printToTerminal,
        printToTerminalAllowed=EVENT_printToTerminalAllowed  # only allow the stops, which are < 40.
        )

    

    print('----><----')
    print(eh)
    eh.start()
    # time.sleep(10)
    #print('<---><----')
    # eh.send_message('aud_l55')
    print('<---><----')
    print(eh)
    
    # return eh
    G['eh']=eh
    return(G)


#%% MAIN -- hope things work
if __name__== "__main__":
    # do the stuff.

    #
    # Starting screen, check the buttons:
    #
    #
    #
    #
    
    
    # do all the event hander stuff:
        # initualize it + make it findable by all subfucntions


    # eh=G['eh']
    # time to start.    

    
    #
    #
    #
    # Run the main loop, defined above:
    #
    #
    # 
    # so this might be a hacky way, but it is short.
    # when you say 'import *', you bring all of the definitions to your current
    # working space. This is horrible for programming, but fantastic for our
    # purposes of just running a script completely.
    # from efl.efl_v6 import *
    
    

    G=init_G()
    G=init_screen(G)
    G=init_logfile(G)
    G=init_stimuli(G)
    G=init_eventcodes(G)
    
    G=init_gng(G)
    
    G=init_reset_clock(G)
    
    G=init_audio(G)
    G=init_visual(G)

    G=start_ev(G)
    
    # if it's NOT main, I have to do this in the pyff thingy.


        
    
    try:
        
        # print(G['eh'].is_alive())
        wait_for_key(G)
        
        measure_artifact_program(G)
                
        test_buttons(G)
        instr_screen0(G)
        
        eo_stim(G)
        ec_stim(G)
        logging.flush()

        
        test_buttons(G)
        instr_screen(G)
        logging.flush()
        
    
        # print(G['eh'].is_alive())
        # print('----><----')
        # G['eh'].send_message('boe!')
        # print('----><----')
        run_main_loop(G)
        logging.flush()
    
        eo_stim(G)
        ec_stim(G)
        end_task(G)
        logging.flush()
        
        # write it away...

        # close window here.
        G['win'].close()
        logging.flush()
        
        
    except KeyboardInterrupt:
        G['eh'].shutdown()
        G['eh'].join()
        G['win'].close()
        logging.flush()
        
    #
    #
    #
    #
    # We end with a little bit of eyes closed:
    #
    #
    #
    





    


    # eyes closed
    
    
    # flash screen
    # the end
    
    # wait for button.
    
    

        





#%% The Rest
#    @asyncio.coroutine
#    def handle_exception_test_it():
#        try:
#            yield From(test_it())
#        except Exception:
#            
#            #print(sys.last_type)
#            #traceback.print_tb(sys.last_traceback)
#            #print("exception consumed")
#            # print('hallo!')
#            # print(traceback)
#            print(sys.exc_info()[1])
#            traceback.print_tb(sys.exc_info()[2])
#            # etype, evalue, etraceback = sys.exec_info()
#            # traceback.format_exc()
#            # print(traceback.fortmat_exec(etraceback))
#            
#    @asyncio.coroutine
#    def handle_exception_handle_audio():
#        try:
#            yield From(handle_audio())
#        except Exception:
#            
#            #print(sys.last_type)
#            #traceback.print_tb(sys.last_traceback)
#            #print("exception consumed")
#            # print('hallo!')
#            # print(traceback)
#            print(sys.exc_info()[1])
#            traceback.print_tb(sys.exc_info()[2])
#            
#            # etype, evalue, etraceback = sys.exec_info()
#            # traceback.format_exc()
#            # print(traceback.fortmat_exec(etraceback))
#            
#            
#    # we debug by CHAINING coroutines. Very very clear, yes. But it's necessity for now.
#    # would be nice to enable this feature in a nicer way for someone like me.
        
        
        

#%% Getting Input

# see: http://easygui.sourceforge.net/tutorial.html#enterbox
# variable = easygui.enterbox('hello','title','text')



# OR -- use psychopy's functions:
# expName = 'loc_v1'  # from the Builder filename that created this script
# expInfo = {'participant':'', 'session':'001'}
# dlg = gui.DlgFromDict(dictionary=expInfo, title=expName)
#
# access via expInfo['participant'], etc.


#%% Gonogo Thoughts
# vis contents is a list that's accessible by the function
# if the function changes its contents, then other functions will be able to
# read in those contents, too.
# I let the functions talk to each other using ... what?

# visContents is a list from handleGoNogo that contains the stuff to be drawn 
# GoNogo's end
# nexFlipTasks is a list/.. or a dict of stuff with function names and arguments
# that handleVisual should call using win.
    
#
#class GoNogo(object):
#    def __init__(self, SSnumber, SSstopgo, myMultiStairs, myVisualContents,nextFlipTasks, newClock, continueRoutine):
#        self.SSnumber=SSnumber
#        self.SSstopgo=SSstopgo
#        self.myMultiStairs=myMultiStairs
#        self.myVisualContents=myVisualContents
#        self.nextFlipTasks=nextFlipTasks
#        self.newClock=newClock
#        self.continueRoutine=continueRoutine
#        
# after some sleep, my brain might be able to conceive of how I could make this with a Object Oriented programming
# in the event loop in any case I should definitely use some kind of function that yields.
# or can I also make coroutine objects?
# and.. how to implement this, then?    
        
        
#%% Starcase usage -- use the starcase to loop over the stop trials:
# myMultiStair.next()
# myMultiStair.addResponse(1)
#
# getting intensities (for later to average over):
#
# myMultiStair.staircases[3].intensities
#    for thisIntensity, thisCondition in myMultiStairs:
#        print(thisIntensity)
#        print(thisCondition)
#        myMultiStairs.addResponse(random.choice([0,1]))
        
        
#%% More Random Stuff

#    visual_evt_codes={'left':{'8':87,'13':137},'right':{'8':88,'13':138}}
#    
#    # these are markers for the frequency analysis
#    visual_evt_codes_begin={'left':{'8':83,'13':133},'right':{'8':84,'13':134}}
#    visual_evt_codes_end={'left':{'8':85,'13':135},'right':{'8':86,'13':136}}
#    
#    # these are the thread starts - which conveniently also denotify what your visual segments
#    # should BE - in case you wish to reconstruct the visual ERP
#    global visual_evt_codes_beginvisthread
#    visual_evt_codes_beginvisthread={'left':{'8':81,'13':131},'right':{'8':82,'13':132}}
#    
#    
#    
#    
#    
#    
#    audio_evt_codes={'left':{'40':41,'55':51},'right':{'40':42,'55':52}}
#    audio_evt_codes_begin={'left':{'40':43,'55':53},'right':{'40':44,'55':54}}
#    audio_evt_codes_end={'left':{'40':45,'55':55},'right':{'40':46,'55':56}}
#    
#    
#    txt_evt_codes = {'normal':100, 'oddball':101}
        
        
#
